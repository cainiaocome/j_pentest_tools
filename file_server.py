#!/usr/bin/env python2.7
# encoding: utf-8

import os
import time
import socket
import traceback
import sys
import struct
import random
import argparse
import threading
from StringIO import StringIO
import json
import hashlib

port = 1023
password = 'f28acc13d27b8ebbb1b18fe76fe7a129'
block_size = 1024*1024
worker_thread_count = 128
timeout = 7

def prefix_len_to_data( data ):
    data_len = len(data)
    data_len = data_len + len(str(data_len)) + 1
    data = str(data_len) + ',' + data
    return data

def prefix_hash_to_data( data ):  # data: str, bytes
    data_sign = hashlib.sha1( data ).hexdigest()
    return str(data_sign) + data

def check_hash( data_with_hash ): # request_data: bytes, str
    sign = data_with_hash[:40]
    if sign != hashlib.sha1(data_with_hash[40:]).hexdigest():
        return False
    else:
        return data_with_hash[40:]

def recvall( connection ):
    data = ''
    packet_len = 2**32
    while len(data)<packet_len:
        packet = connection.recv(1024*256)
        if not packet:
            return data[ str(data).find(',')+1: ]
        else:
            data = data + packet
        if str(data).find(',')!=-1:
            packet_len = int(str(data).split(',')[0])
    return data[ str(data).find(',')+1: ]

def start_server():
    address = ('0.0.0.0', port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind( address)
    s.listen( 7 )

    def handle_request( connection ):
        try:
            data = recvall( connection )
            print data
            data = check_hash( data )
            if data:
                data = json.load( StringIO(str(data)) )
                if data['password'] == password:
                    if data['request_method'] == 'get_info':
                        file_size = os.path.getsize( data['file_path'] )
                        data = { 'file_size': file_size }
                        data = prefix_hash_to_data( json.dumps(data) )
                        data = prefix_len_to_data( data )
                        connection.sendall(data)
                    elif data['request_method'] == 'get_block':
                        with open(data['file_path'], 'rb') as f:
                            print 'get_block', data['block_index'], data['file_path']
                            f.seek(block_size*data['block_index'], 0) # read from file start
                            data = f.read(block_size)
                            data = prefix_hash_to_data( data )
                            data = prefix_len_to_data( data )
                            connection.sendall(data)
            connection.close()
        except:
            sys.exc_clear()
    while True:
        try:
            connection, addr = s.accept()
            print 'received connection from', '{}:{}'.format( addr[0], str(addr[1]) )
            worker_thread = threading.Thread(target=handle_request, args=[connection])
            worker_thread.daemon = True
            worker_thread.start()
        except:
            traceback.print_exc()
            sys.exc_clear()

def start_client(server, file_path):
    block_list = []
    block_list_write_lock = threading.Lock()
    # get_info
    while True:
        try:
            data = {
                    'password':password,
                    'file_path':file_path,
                    'request_method':'get_info',
                   }
            data = prefix_hash_to_data( json.dumps(data) )
            data = prefix_len_to_data( data )
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout( timeout )
            s.connect( (server, port) )
            s.sendall(data)
            data = recvall( s )
            s.close()
            data = check_hash( data )
            if not data:
                continue
            data = json.load( StringIO(str(data)) )
            block_count = data['file_size'] / block_size
            if data['file_size'] % block_size>0:
                block_count = block_count + 1
            map( lambda x:block_list.append('to_get'), range(block_count) )
            break
        except:
            traceback.print_exc()
            sys.exc_clear()
    def check_finished():
        remain_job_list = filter(lambda x:True if x=='to_get' or x=='getting' else False, block_list)
        print 'remain_job_list len:', len(remain_job_list)
        if len(remain_job_list)==0:
            return True
        else:
            return False
    def check_to_get():
        to_get_list = filter(lambda x:True if x=='to_get' else False, block_list)
        return len(to_get_list)
    def get_getting_index_list():
        getting_index_list = []
        for index in range(len(block_list)):
            if block_list[index]=='getting':
                getting_index_list.append( index )
        return getting_index_list

    def get_block_worker():
        while True:
            if check_finished():
                return
            block_list_write_lock.acquire()
            for index in range(len(block_list)):
                if block_list[index]=='to_get':
                    block_list[index]='getting'
                    break
            else: # all is done or being done
                index = random.choice( get_getting_index_list() )
            block_list_write_lock.release()
            while True:
                data = {
                        'password':password,
                        'file_path':file_path,
                        'request_method':'get_block',
                        'block_index':index,
                       }
                data = prefix_hash_to_data( json.dumps(data) )
                data = prefix_len_to_data( data )
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout( timeout )
                    s.connect( (server, port) )
                    s.sendall(data)
                    data = recvall( s )
                    s.close()
                    data = check_hash( data )
                    if data:
                        block_list_write_lock.acquire()
                        if block_list[index]=='getting': # this job may be done by another thread if thread is spare
                            block_list[index] = data
                        block_list_write_lock.release()
                        break
                    else:
                        print 'sign error'
                except:
                    traceback.print_exc()
                    sys.exc_clear()
    for worker_thread_index in range(worker_thread_count):
        worker_thread = threading.Thread( target=get_block_worker, args=[] )
        worker_thread.daemon = True
        worker_thread.start()
    while True:
        if check_finished():
            break
        else:
            time.sleep(3)
    with open(os.path.basename(file_path), 'wb' ) as f:
        for block in block_list:
            f.write( block )
    sys.exit(0)
if __name__=='__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-t', '--type', type=str, required=True, help='server or client')
    argparser.add_argument('-s', '--server', type=str, default='', required=False, help='client specified server')
    argparser.add_argument('-f', '--file', type=str, default='', required=False, help='client specified file path')
    args = argparser.parse_args()
    if args.type == 'client':
        if args.server=='':
            print 'server address required' 
            sys.exit(0)
        if args.file=='':
            print 'file path on remote server required'
            sys.exit(0)
        start_client(args.server, args.file)

    elif args.type == 'server':
        start_server()

    else:
        print 'unkown type, please specify client or server to run'
